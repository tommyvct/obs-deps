; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TTL	c:\users\ws103\desktop\zlib-1.2.11\inftrees.c
	ARM64

	AREA	|.drectve|, DRECTVE

	EXPORT	|inflate_copyright| [ DATA ]
	%	10
|?dext@?1??inflate_table@@9@9| DCW 0x10			; `inflate_table'::`2'::dext
	DCW	0x10
	DCW	0x10
	DCW	0x10
	DCW	0x11
	DCW	0x11
	DCW	0x12
	DCW	0x12
	DCW	0x13
	DCW	0x13
	DCW	0x14
	DCW	0x14
	DCW	0x15
	DCW	0x15
	DCW	0x16
	DCW	0x16
	DCW	0x17
	DCW	0x17
	DCW	0x18
	DCW	0x18
	DCW	0x19
	DCW	0x19
	DCW	0x1a
	DCW	0x1a
	DCW	0x1b
	DCW	0x1b
	DCW	0x1c
	DCW	0x1c
	DCW	0x1d
	DCW	0x1d
	DCW	0x40
	DCW	0x40
|?lext@?1??inflate_table@@9@9| DCW 0x10			; `inflate_table'::`2'::lext
	DCW	0x10
	DCW	0x10
	DCW	0x10
	DCW	0x10
	DCW	0x10
	DCW	0x10
	DCW	0x10
	DCW	0x11
	DCW	0x11
	DCW	0x11
	DCW	0x11
	DCW	0x12
	DCW	0x12
	DCW	0x12
	DCW	0x12
	DCW	0x13
	DCW	0x13
	DCW	0x13
	DCW	0x13
	DCW	0x14
	DCW	0x14
	DCW	0x14
	DCW	0x14
	DCW	0x15
	DCW	0x15
	DCW	0x15
	DCW	0x15
	DCW	0x10
	DCW	0x4d
	DCW	0xca
	%	2
|?lbase@?1??inflate_table@@9@9| DCW 0x3			; `inflate_table'::`2'::lbase
	DCW	0x4
	DCW	0x5
	DCW	0x6
	DCW	0x7
	DCW	0x8
	DCW	0x9
	DCW	0xa
	DCW	0xb
	DCW	0xd
	DCW	0xf
	DCW	0x11
	DCW	0x13
	DCW	0x17
	DCW	0x1b
	DCW	0x1f
	DCW	0x23
	DCW	0x2b
	DCW	0x33
	DCW	0x3b
	DCW	0x43
	DCW	0x53
	DCW	0x63
	DCW	0x73
	DCW	0x83
	DCW	0xa3
	DCW	0xc3
	DCW	0xe3
	DCW	0x102
	DCW	0x0
	DCW	0x0
	%	2
|?dbase@?1??inflate_table@@9@9| DCW 0x1			; `inflate_table'::`2'::dbase
	DCW	0x2
	DCW	0x3
	DCW	0x4
	DCW	0x5
	DCW	0x7
	DCW	0x9
	DCW	0xd
	DCW	0x11
	DCW	0x19
	DCW	0x21
	DCW	0x31
	DCW	0x41
	DCW	0x61
	DCW	0x81
	DCW	0xc1
	DCW	0x101
	DCW	0x181
	DCW	0x201
	DCW	0x301
	DCW	0x401
	DCW	0x601
	DCW	0x801
	DCW	0xc01
	DCW	0x1001
	DCW	0x1801
	DCW	0x2001
	DCW	0x3001
	DCW	0x4001
	DCW	0x6001
	DCW	0x0
	DCW	0x0
|inflate_copyright| DCB " inflate 1.2.11 Copyright 1995-2017 Mark Adler ", 0x0
	EXPORT	|inflate_table|

	AREA	|.pdata|, PDATA
|$pdata$inflate_table| DCD imagerel |$LN182|
	DCD	0x5090519
	;Flags[SingleProEpi] functionLength[1304] RegF[0] RegI[9] H[0] frameChainReturn[UnChained] frameSize[160]
; Function compile flags: /Ogtp
; File C:\Users\ws103\Desktop\zlib-1.2.11\inftrees.c

	AREA	|.text$mn|, CODE, ARM64

  00000		 |inflate_table| PROC

; 39   : {

  00000		 |$LN182|
  00000	a9bb53f3	 stp         x19,x20,[sp,#-0x50]!
  00004	a9015bf5	 stp         x21,x22,[sp,#0x10]
  00008	a90263f7	 stp         x23,x24,[sp,#0x20]
  0000c	a9036bf9	 stp         x25,x26,[sp,#0x30]
  00010	f90023fb	 str         x27,[sp,#0x40]
  00014	d10143ff	 sub         sp,sp,#0x50

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00018	910023e8	 add         x8,sp,#8
  0001c	a9007d1f	 stp         xzr,xzr,[x8]
  00020	2a0003f6	 mov         w22,w0
  00024	a9017d1f	 stp         xzr,xzr,[x8,#0x10]
  00028	aa0103fa	 mov         x26,x1
  0002c	aa0403fb	 mov         x27,x4
  00030	aa0503f5	 mov         x21,x5

; 108  :         count[len] = 0;
; 109  :     for (sym = 0; sym < codes; sym++)

  00034	34000002	 cbz         w2,|$LN6@inflate_ta|
  00038	aa1a03ec	 mov         x12,x26
  0003c	2a0203eb	 mov         w11,w2
  00040	910023ed	 add         x13,sp,#8
  00044		 |$LL7@inflate_ta|

; 110  :         count[lens[sym]]++;

  00044	7840258a	 ldrh        w10,[x12],#2
  00048	5100056b	 sub         w11,w11,#1
  0004c	786a79a8	 ldrh        w8,[x13,x10 lsl #1]
  00050	11000508	 add         w8,w8,#1
  00054	782a79a8	 strh        w8,[x13,x10 lsl #1]
  00058	3500000b	 cbnz        w11,|$LL7@inflate_ta|
  0005c		 |$LN6@inflate_ta|

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  0005c	b940036b	 ldr         w11,[x27]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00060	528001ef	 mov         w15,#0xF
  00064	910023ec	 add         x12,sp,#8
  00068	910023ee	 add         x14,sp,#8
  0006c	910023ed	 add         x13,sp,#8
  00070		 |$LL10@inflate_ta|

; 115  :         if (count[max] != 0) break;

  00070	786f5988	 ldrh        w8,[x12,w15 uxtw #1]
  00074	35000008	 cbnz        w8,|$LN78@inflate_ta|
  00078	510009ea	 sub         w10,w15,#2
  0007c	11000548	 add         w8,w10,#1
  00080	786859c9	 ldrh        w9,[x14,w8 uxtw #1]
  00084	35000009	 cbnz        w9,|$LN145@inflate_ta|
  00088	786a59a8	 ldrh        w8,[x13,w10 uxtw #1]
  0008c	35000008	 cbnz        w8,|$LN146@inflate_ta|

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00090	51000def	 sub         w15,w15,#3
  00094	3500000f	 cbnz        w15,|$LL10@inflate_ta|
  00098	14000004	 b           |$LN78@inflate_ta|
  0009c		 |$LN146@inflate_ta|

; 115  :         if (count[max] != 0) break;

  0009c	510009ef	 sub         w15,w15,#2
  000a0	14000002	 b           |$LN78@inflate_ta|
  000a4		 |$LN145@inflate_ta|
  000a4	510005ef	 sub         w15,w15,#1
  000a8		 |$LN78@inflate_ta|

; 116  :     if (root > max) root = max;
; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000a8	6b0f017f	 cmp         w11,w15
  000ac	1a8f9169	 csells      w9,w11,w15
  000b0	3500000f	 cbnz        w15,|$LN37@inflate_ta|

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  000b4	52800808	 mov         w8,#0x40

; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;

  000b8	790007ff	 strh        wzr,[sp,#2]

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000bc	f9400069	 ldr         x9,[x3]
  000c0	5280002b	 mov         w11,#1
  000c4	390003e8	 strb        w8,[sp]
  000c8	390007eb	 strb        w11,[sp,#1]

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  000cc	52800000	 mov         w0,#0
  000d0	b94003e8	 ldr         w8,[sp]
  000d4	b9000128	 str         w8,[x9]
  000d8	f9400069	 ldr         x9,[x3]
  000dc	9100112a	 add         x10,x9,#4
  000e0	f900006a	 str         x10,[x3]
  000e4	b9000148	 str         w8,[x10]
  000e8	f9400069	 ldr         x9,[x3]
  000ec	9100112a	 add         x10,x9,#4
  000f0	f900006a	 str         x10,[x3]
  000f4	b900036b	 str         w11,[x27]
  000f8	14000101	 b           |$LN1@inflate_ta|
  000fc		 |$LN37@inflate_ta|

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000fc	5280002e	 mov         w14,#1
  00100	710005ff	 cmp         w15,#1
  00104	54000009	 bls         |$LN79@inflate_ta|
  00108	910023ea	 add         x10,sp,#8
  0010c		 |$LL13@inflate_ta|

; 127  :         if (count[min] != 0) break;

  0010c	786e5948	 ldrh        w8,[x10,w14 uxtw #1]
  00110	35000008	 cbnz        w8,|$LN79@inflate_ta|

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00114	110005ce	 add         w14,w14,#1
  00118	6b0f01df	 cmp         w14,w15
  0011c	54000003	 blo         |$LL13@inflate_ta|
  00120		 |$LN79@inflate_ta|

; 128  :     if (root < min) root = min;
; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00120	6b0e013f	 cmp         w9,w14
  00124	1a8e2133	 cselhs      w19,w9,w14
  00128	52800028	 mov         w8,#1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  0012c	5280002a	 mov         w10,#1
  00130	910023eb	 add         x11,sp,#8
  00134		 |$LL16@inflate_ta|

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00134	786a5969	 ldrh        w9,[x11,w10 uxtw #1]
  00138	531f7908	 lsl         w8,w8,#1
  0013c	4b090108	 sub         w8,w8,w9

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00140	37f80008	 tbnz        x8,#0x1F,|$LN42@inflate_ta|

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00144	1100054a	 add         w10,w10,#1
  00148	71003d5f	 cmp         w10,#0xF
  0014c	54000009	 bls         |$LL16@inflate_ta|

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  00150	7100011f	 cmp         w8,#0
  00154	5400000d	 ble         |$LN41@inflate_ta|
  00158	710002df	 cmp         w22,#0
  0015c	7a4119e0	 ccmpne      w15,#1,#0
  00160	54000001	 bne         |$LN42@inflate_ta|
  00164		 |$LN41@inflate_ta|

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;
; 142  :     for (len = 1; len < MAXBITS; len++)
; 143  :         offs[len + 1] = offs[len] + count[len];

  00164	794017e9	 ldrh        w9,[sp,#0xA]
  00168	790057ff	 strh        wzr,[sp,#0x2A]

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0016c	5280000b	 mov         w11,#0
  00170	79401be8	 ldrh        w8,[sp,#0xC]
  00174	79005be9	 strh        w9,[sp,#0x2C]
  00178	0b090108	 add         w8,w8,w9
  0017c	53003d09	 uxth        w9,w8
  00180	79401fe8	 ldrh        w8,[sp,#0xE]
  00184	79005fe9	 strh        w9,[sp,#0x2E]
  00188	0b080128	 add         w8,w9,w8
  0018c	53003d0a	 uxth        w10,w8
  00190	794023e8	 ldrh        w8,[sp,#0x10]
  00194	790063ea	 strh        w10,[sp,#0x30]
  00198	0b080148	 add         w8,w10,w8
  0019c	53003d09	 uxth        w9,w8
  001a0	794027e8	 ldrh        w8,[sp,#0x12]
  001a4	790067e9	 strh        w9,[sp,#0x32]
  001a8	0b080128	 add         w8,w9,w8
  001ac	53003d0a	 uxth        w10,w8
  001b0	79402be8	 ldrh        w8,[sp,#0x14]
  001b4	79006bea	 strh        w10,[sp,#0x34]
  001b8	0b080148	 add         w8,w10,w8
  001bc	53003d09	 uxth        w9,w8
  001c0	79402fe8	 ldrh        w8,[sp,#0x16]
  001c4	79006fe9	 strh        w9,[sp,#0x36]
  001c8	0b080128	 add         w8,w9,w8
  001cc	53003d0a	 uxth        w10,w8
  001d0	794033e8	 ldrh        w8,[sp,#0x18]
  001d4	790073ea	 strh        w10,[sp,#0x38]
  001d8	0b080148	 add         w8,w10,w8
  001dc	53003d09	 uxth        w9,w8
  001e0	794037e8	 ldrh        w8,[sp,#0x1A]
  001e4	790077e9	 strh        w9,[sp,#0x3A]
  001e8	0b080128	 add         w8,w9,w8
  001ec	53003d0a	 uxth        w10,w8
  001f0	79403be8	 ldrh        w8,[sp,#0x1C]
  001f4	79007bea	 strh        w10,[sp,#0x3C]
  001f8	0b080148	 add         w8,w10,w8
  001fc	53003d09	 uxth        w9,w8
  00200	79403fe8	 ldrh        w8,[sp,#0x1E]
  00204	79007fe9	 strh        w9,[sp,#0x3E]
  00208	0b080128	 add         w8,w9,w8
  0020c	53003d0a	 uxth        w10,w8
  00210	794043e8	 ldrh        w8,[sp,#0x20]
  00214	790083ea	 strh        w10,[sp,#0x40]
  00218	0b080148	 add         w8,w10,w8
  0021c	53003d09	 uxth        w9,w8
  00220	794047e8	 ldrh        w8,[sp,#0x22]
  00224	790087e9	 strh        w9,[sp,#0x42]
  00228	0b080128	 add         w8,w9,w8
  0022c	53003d0a	 uxth        w10,w8
  00230	79404be8	 ldrh        w8,[sp,#0x24]
  00234	79008bea	 strh        w10,[sp,#0x44]
  00238	0b080148	 add         w8,w10,w8
  0023c	79008fe8	 strh        w8,[sp,#0x46]
  00240	34000002	 cbz         w2,|$LN21@inflate_ta|
  00244	aa1a03ec	 mov         x12,x26
  00248	9100a3e7	 add         x7,sp,#0x28
  0024c	9100a3ed	 add         x13,sp,#0x28
  00250		 |$LL22@inflate_ta|

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00250	78402588	 ldrh        w8,[x12],#2
  00254	34000008	 cbz         w8,|$LN20@inflate_ta|
  00258	786878e8	 ldrh        w8,[x7,x8 lsl #1]
  0025c	78287aab	 strh        w11,[x21,x8 lsl #1]
  00260	785fe18a	 ldurh       w10,[x12,#-2]
  00264	786a79a8	 ldrh        w8,[x13,x10 lsl #1]
  00268	11000508	 add         w8,w8,#1
  0026c	782a79a8	 strh        w8,[x13,x10 lsl #1]
  00270		 |$LN20@inflate_ta|

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00270	1100056b	 add         w11,w11,#1
  00274	6b02017f	 cmp         w11,w2
  00278	54000003	 blo         |$LL22@inflate_ta|
  0027c		 |$LN21@inflate_ta|

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0027c	f9400066	 ldr         x6,[x3]
  00280	34000016	 cbz         w22,|$LN44@inflate_ta|
  00284	710006df	 cmp         w22,#1
  00288	90000008	 adrp        x8,|?dext@?1??inflate_table@@9@9|
  0028c	54000000	 beq         |$LN45@inflate_ta|

; 190  :         break;
; 191  :     default:    /* DISTS */
; 192  :         base = dbase;

  00290	91000117	 add         x23,x8,PageOffset(|?dext@?1??inflate_table@@9@9|)

; 193  :         extra = dext;
; 194  :         match = 0;

  00294	52800028	 mov         w8,#1
  00298	1ad32108	 lsl         w8,w8,w19

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */
; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */
; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */
; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0029c	2a0803e2	 mov         w2,w8
  002a0	2a0803e5	 mov         w5,w8
  002a4	51000518	 sub         w24,w8,#1
  002a8	52800001	 mov         w1,#0
  002ac	910302f9	 add         x25,x23,#0xC0
  002b0	71000adf	 cmp         w22,#2
  002b4	54000001	 bne         |$LN170@inflate_ta|
  002b8	910302f9	 add         x25,x23,#0xC0
  002bc	51000518	 sub         w24,w8,#1
  002c0	7109411f	 cmp         w8,#0x250
  002c4	54000009	 bls         |$LN170@inflate_ta|
  002c8		 |$LN62@inflate_ta|

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  002c8	52800020	 mov         w0,#1
  002cc	1400008c	 b           |$LN1@inflate_ta|
  002d0		 |$LN45@inflate_ta|

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         extra = lext;
; 189  :         match = 257;

  002d0	52800029	 mov         w9,#1
  002d4	1ad32122	 lsl         w2,w9,w19
  002d8	2a0203e5	 mov         w5,w2

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */
; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */
; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */
; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  002dc	710d50bf	 cmp         w5,#0x354
  002e0	91000108	 add         x8,x8,PageOffset(|?dext@?1??inflate_table@@9@9|)
  002e4	52802021	 mov         w1,#0x101
  002e8	54000008	 bhi         |$LN62@inflate_ta|
  002ec	91020119	 add         x25,x8,#0x80
  002f0	91010117	 add         x23,x8,#0x40
  002f4	14000007	 b           |$LN178@inflate_ta|
  002f8		 |$LN44@inflate_ta|

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */
; 184  :         match = 20;

  002f8	52800028	 mov         w8,#1
  002fc	1ad32102	 lsl         w2,w8,w19
  00300	2a0203e5	 mov         w5,w2
  00304	aa1503f7	 mov         x23,x21
  00308	aa1503f9	 mov         x25,x21
  0030c	52800281	 mov         w1,#0x14
  00310		 |$LN178@inflate_ta|

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00310	510004b8	 sub         w24,w5,#1
  00314		 |$LN170@inflate_ta|
  00314	52800007	 mov         w7,#0
  00318	52800000	 mov         w0,#0
  0031c	52800004	 mov         w4,#0
  00320	12800014	 mov         w20,#-1
  00324		 |$LN180@inflate_ta|

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;
; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  00324	52800c0b	 mov         w11,#0x60
  00328		 |$LL25@inflate_ta|

; 217  :         if (work[sym] + 1U < match) {

  00328	78605aa9	 ldrh        w9,[x21,w0 uxtw #1]
  0032c	4b0401ca	 sub         w10,w14,w4
  00330	390007ea	 strb        w10,[sp,#1]
  00334	11000528	 add         w8,w9,#1
  00338	6b01011f	 cmp         w8,w1
  0033c	54000002	 bhs         |$LN50@inflate_ta|

; 218  :             here.op = (unsigned char)0;

  00340	390003ff	 strb        wzr,[sp]

; 219  :             here.val = work[sym];

  00344	790007e9	 strh        w9,[sp,#2]

; 220  :         }

  00348	1400000b	 b           |$LN53@inflate_ta|
  0034c		 |$LN50@inflate_ta|

; 221  :         else if (work[sym] >= match) {

  0034c	6b01013f	 cmp         w9,w1
  00350	54000003	 blo         |$LN52@inflate_ta|

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  00354	4b010129	 sub         w9,w9,w1
  00358	78695ae8	 ldrh        w8,[x23,w9 uxtw #1]

; 223  :             here.val = base[work[sym] - match];

  0035c	78695b29	 ldrh        w9,[x25,w9 uxtw #1]
  00360	390003e8	 strb        w8,[sp]
  00364	790007e9	 strh        w9,[sp,#2]

; 224  :         }

  00368	14000003	 b           |$LN53@inflate_ta|
  0036c		 |$LN52@inflate_ta|

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  0036c	390003eb	 strb        w11,[sp]

; 227  :             here.val = 0;

  00370	790007ff	 strh        wzr,[sp,#2]
  00374		 |$LN53@inflate_ta|

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  00374	52800028	 mov         w8,#1
  00378	1aca210b	 lsl         w11,w8,w10
  0037c	1ac424e8	 lsr         w8,w7,w4

; 232  :         fill = 1U << curr;

  00380	2a0203e9	 mov         w9,w2
  00384	0b09010a	 add         w10,w8,w9
  00388	b94003e8	 ldr         w8,[sp]

; 233  :         min = fill;                 /* save offset to next table */

  0038c	2a0903ed	 mov         w13,w9
  00390		 |$LL30@inflate_ta|

; 234  :         do {
; 235  :             fill -= incr;

  00390	4b0b014a	 sub         w10,w10,w11

; 236  :             next[(huff >> drop) + fill] = here;

  00394	b82a58c8	 str         w8,[x6,w10 uxtw #2]
  00398	4b0b0129	 sub         w9,w9,w11

; 237  :         } while (fill != 0);

  0039c	35000009	 cbnz        w9,|$LL30@inflate_ta|

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  003a0	510005c9	 sub         w9,w14,#1
  003a4	52800028	 mov         w8,#1
  003a8	1ac9210b	 lsl         w11,w8,w9

; 241  :         while (huff & incr)

  003ac	6a07017f	 tst         w11,w7
  003b0	54000000	 beq         |$LN32@inflate_ta|
  003b4		 |$LL31@inflate_ta|

; 242  :             incr >>= 1;

  003b4	53017d6b	 lsr         w11,w11,#1
  003b8	6a07017f	 tst         w11,w7
  003bc	54000001	 bne         |$LL31@inflate_ta|
  003c0		 |$LN32@inflate_ta|

; 243  :         if (incr != 0) {
; 244  :             huff &= incr - 1;

  003c0	51000568	 sub         w8,w11,#1
  003c4	0a070109	 and         w9,w8,w7

; 245  :             huff += incr;

  003c8	0b0b012a	 add         w10,w9,w11
  003cc	7100017f	 cmp         w11,#0

; 246  :         }
; 247  :         else
; 248  :             huff = 0;
; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;
; 252  :         if (--(count[len]) == 0) {

  003d0	910023eb	 add         x11,sp,#8
  003d4	786e5968	 ldrh        w8,[x11,w14 uxtw #1]
  003d8	529fffe9	 mov         w9,#0xFFFF
  003dc	1a8a03e7	 cseleq      w7,wzr,w10
  003e0	11000400	 add         w0,w0,#1
  003e4	0b090108	 add         w8,w8,w9
  003e8	53003d09	 uxth        w9,w8
  003ec	782e5969	 strh        w9,[x11,w14 uxtw #1]
  003f0	35000009	 cbnz        w9,|$LN56@inflate_ta|

; 253  :             if (len == max) break;

  003f4	6b0f01df	 cmp         w14,w15
  003f8	54000000	 beq         |$LN82@inflate_ta|

; 254  :             len = lens[work[sym]];

  003fc	78605aa8	 ldrh        w8,[x21,w0 uxtw #1]
  00400	78687b4e	 ldrh        w14,[x26,x8 lsl #1]
  00404		 |$LN56@inflate_ta|

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  00404	6b1301df	 cmp         w14,w19
  00408	52800c0b	 mov         w11,#0x60
  0040c	54000009	 bls         |$LL25@inflate_ta|
  00410	0a07030c	 and         w12,w24,w7
  00414	6b14019f	 cmp         w12,w20
  00418	54000000	 beq         |$LL25@inflate_ta|

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  0041c	7100009f	 cmp         w4,#0

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  00420	8b2d48c6	 add         x6,x6,w13,uxtw #2
  00424	1a840264	 cseleq      w4,w19,w4

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  00428	4b0401cb	 sub         w11,w14,w4

; 268  :             left = (int)(1 << curr);

  0042c	52800028	 mov         w8,#1
  00430	1acb210a	 lsl         w10,w8,w11

; 269  :             while (curr + drop < max) {

  00434	6b0f01df	 cmp         w14,w15
  00438	54000002	 bhs         |$LN81@inflate_ta|

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  0043c	2a0e03e9	 mov         w9,w14
  00440	910023ed	 add         x13,sp,#8
  00444		 |$LL33@inflate_ta|

; 270  :                 left -= count[curr + drop];

  00444	786959a8	 ldrh        w8,[x13,w9 uxtw #1]
  00448	4b08014a	 sub         w10,w10,w8

; 271  :                 if (left <= 0) break;

  0044c	7100015f	 cmp         w10,#0
  00450	5400000d	 ble         |$LN81@inflate_ta|

; 272  :                 curr++;

  00454	11000529	 add         w9,w9,#1
  00458	6b0f013f	 cmp         w9,w15
  0045c	1100056b	 add         w11,w11,#1

; 273  :                 left <<= 1;

  00460	531f794a	 lsl         w10,w10,#1
  00464	54000003	 blo         |$LL33@inflate_ta|
  00468		 |$LN81@inflate_ta|

; 274  :             }
; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;

  00468	52800028	 mov         w8,#1
  0046c	1acb2102	 lsl         w2,w8,w11
  00470	0b050045	 add         w5,w2,w5

; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  00474	710006df	 cmp         w22,#1
  00478	54000001	 bne         |$LN63@inflate_ta|
  0047c	710d50bf	 cmp         w5,#0x354
  00480	14000004	 b           |$LN179@inflate_ta|
  00484		 |$LN63@inflate_ta|
  00484	71000adf	 cmp         w22,#2
  00488	54000001	 bne         |$LN61@inflate_ta|
  0048c	710940bf	 cmp         w5,#0x250
  00490		 |$LN179@inflate_ta|

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  00490	54000008	 bhi         |$LN62@inflate_ta|
  00494		 |$LN61@inflate_ta|

; 284  :             (*table)[low].op = (unsigned char)curr;

  00494	f9400068	 ldr         x8,[x3]
  00498	2a0c03f4	 mov         w20,w12
  0049c	d37e7e8d	 ubfiz       x13,x20,#2,#0x20
  004a0	382d690b	 strb        w11,[x8,x13]

; 285  :             (*table)[low].bits = (unsigned char)root;

  004a4	f9400069	 ldr         x9,[x3]
  004a8	8b0d012a	 add         x10,x9,x13
  004ac	39000553	 strb        w19,[x10,#1]

; 286  :             (*table)[low].val = (unsigned short)(next - *table);

  004b0	f940006c	 ldr         x12,[x3]
  004b4	cb0c00c8	 sub         x8,x6,x12
  004b8	9342fd09	 asr         x9,x8,#2
  004bc	8b0d018a	 add         x10,x12,x13
  004c0	79000549	 strh        w9,[x10,#2]

; 287  :         }
; 288  :     }

  004c4	17ffff98	 b           |$LN180@inflate_ta|
  004c8		 |$LN82@inflate_ta|

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  004c8	34000007	 cbz         w7,|$LN64@inflate_ta|

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */

  004cc	52800808	 mov         w8,#0x40

; 295  :         here.bits = (unsigned char)(len - drop);
; 296  :         here.val = (unsigned short)0;

  004d0	790007ff	 strh        wzr,[sp,#2]
  004d4	390003e8	 strb        w8,[sp]

; 297  :         next[huff] = here;

  004d8	b94003e8	 ldr         w8,[sp]
  004dc	b82758c8	 str         w8,[x6,w7 uxtw #2]
  004e0		 |$LN64@inflate_ta|

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  004e0	f9400068	 ldr         x8,[x3]

; 302  :     *bits = root;
; 303  :     return 0;

  004e4	52800000	 mov         w0,#0
  004e8	8b254909	 add         x9,x8,w5,uxtw #2
  004ec	f9000069	 str         x9,[x3]
  004f0	b9000373	 str         w19,[x27]
  004f4	14000002	 b           |$LN1@inflate_ta|
  004f8		 |$LN42@inflate_ta|

; 138  :         return -1;                      /* incomplete set */

  004f8	12800000	 mov         w0,#-1
  004fc		 |$LN1@inflate_ta|
  004fc	910143ff	 add         sp,sp,#0x50
  00500	f94023fb	 ldr         x27,[sp,#0x40]
  00504	a9436bf9	 ldp         x25,x26,[sp,#0x30]
  00508	a94263f7	 ldp         x23,x24,[sp,#0x20]
  0050c	a9415bf5	 ldp         x21,x22,[sp,#0x10]
  00510	a8c553f3	 ldp         x19,x20,[sp],#0x50
  00514	d65f03c0	 ret

			 ENDP  ; |inflate_table|

	END
